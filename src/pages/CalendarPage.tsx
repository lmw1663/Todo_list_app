import React, { useState, useEffect } from 'react';
import { useAuth } from '../hooks/useAuth';
import { collection, getDocs, query, where, orderBy } from 'firebase/firestore';
import { db } from '../services/firebase';
import { getCycleByDate } from '../services/sleepCycleService';
import type { Todo, Goal, Memo, Counter } from '../types/models';
import { 
  ChevronLeftIcon, 
  ChevronRightIcon,
  ClockIcon,
  CheckCircleIcon,
  FlagIcon,
  DocumentTextIcon
} from '@heroicons/react/24/outline';
import '../styles/Calendar.css';

interface DayData {
  date: Date;
  todos: Todo[];
  completedTodos: Todo[];
  goals: Goal[];
  memos: Memo[];
  sleepData?: {
    sleepStart: Date;
    sleepEnd: Date;
    duration: number;
    counters: Record<string, number>;
  };
}

const CalendarPage: React.FC = () => {
  const { user } = useAuth();
  const [currentDate, setCurrentDate] = useState(new Date());
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [calendarData, setCalendarData] = useState<Record<string, DayData>>({});
  const [loading, setLoading] = useState(true);

  // Îã¨Î†• Îç∞Ïù¥ÌÑ∞ Î°úÎìú
  useEffect(() => {
    const loadCalendarData = async () => {
      if (!user?.id) return;

      setLoading(true);
      const data: Record<string, DayData> = {};

      try {
        // ÌòÑÏû¨ ÏõîÏùò Ï≤´ÎÇ†Í≥º ÎßàÏßÄÎßâÎÇ†
        const startOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
        const endOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);

        // Î™®Îì† Îç∞Ïù¥ÌÑ∞Î•º Î≥ëÎ†¨Î°ú Î°úÎìú
        const [todosSnapshot, goalsSnapshot, memosSnapshot] = await Promise.all([
          getDocs(collection(db, 'users', user.id, 'todos')),
          getDocs(collection(db, 'users', user.id, 'goals')),
          getDocs(collection(db, 'users', user.id, 'memos'))
        ]);

        // Îç∞Ïù¥ÌÑ∞ ÌååÏã±
        const todos = todosSnapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data(),
          createdAt: doc.data().createdAt?.toDate?.() || new Date(),
          dueDate: doc.data().dueDate === 'infinity' ? 'infinity' : doc.data().dueDate?.toDate?.() || new Date()
        } as Todo));

        const goals = goalsSnapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data(),
          createdAt: doc.data().createdAt?.toDate?.() || new Date(),
          dueDate: doc.data().dueDate?.toDate?.() || new Date()
        } as Goal));

        const memos = memosSnapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data(),
          createdAt: doc.data().createdAt?.toDate?.() || new Date()
        } as Memo));

        // Îã¨Î†•Ïùò Í∞Å ÎÇ†ÏßúÏóê Îç∞Ïù¥ÌÑ∞ Ìï†Îãπ
        for (let date = new Date(startOfMonth); date <= endOfMonth; date.setDate(date.getDate() + 1)) {
          const dateKey = date.toISOString().split('T')[0];
          const dayStart = new Date(date);
          const dayEnd = new Date(date);
          dayEnd.setHours(23, 59, 59, 999);

          // Ìï¥Îãπ ÎÇ†ÏßúÏùò ÏàòÎ©¥ ÏÇ¨Ïù¥ÌÅ¥ Îç∞Ïù¥ÌÑ∞
          const sleepCycle = await getCycleByDate(date);

          data[dateKey] = {
            date: new Date(date),
            todos: todos.filter(todo => {
              if (todo.dueDate === 'infinity') return false;
              const dueDate = new Date(todo.dueDate as Date);
              return dueDate >= dayStart && dueDate <= dayEnd;
            }),
            completedTodos: todos.filter(todo => {
              if (todo.status !== 'done') return false;
              const createdDate = new Date(todo.createdAt);
              return createdDate >= dayStart && createdDate <= dayEnd;
            }),
            goals: goals.filter(goal => {
              const dueDate = new Date(goal.dueDate);
              return dueDate >= dayStart && dueDate <= dayEnd;
            }),
            memos: memos.filter(memo => {
              const createdDate = new Date(memo.createdAt);
              return createdDate >= dayStart && createdDate <= dayEnd;
            }),
            sleepData: sleepCycle ? {
              sleepStart: sleepCycle.sleepStart,
              sleepEnd: sleepCycle.sleepEnd,
              duration: (sleepCycle as any).duration || 0,
              counters: (sleepCycle as any).counters || {}
            } : undefined
          };
        }

        setCalendarData(data);
      } catch (error) {
        console.error('Ï∫òÎ¶∞Îçî Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïò§Î•ò:', error);
      } finally {
        setLoading(false);
      }
    };

    loadCalendarData();
  }, [currentDate, user?.id]);

  // Îã¨Î†• ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò
  const navigateMonth = (direction: 'prev' | 'next') => {
    const newDate = new Date(currentDate);
    if (direction === 'prev') {
      newDate.setMonth(newDate.getMonth() - 1);
    } else {
      newDate.setMonth(newDate.getMonth() + 1);
    }
    setCurrentDate(newDate);
  };

  // Îã¨Î†• Î†åÎçîÎßÅ
  const renderCalendar = () => {
    const year = currentDate.getFullYear();
    const month = currentDate.getMonth();
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const startDate = new Date(firstDay);
    startDate.setDate(startDate.getDate() - firstDay.getDay());

    const days = [];
    const currentDay = new Date(startDate);

    for (let week = 0; week < 6; week++) {
      const weekDays = [];
      for (let day = 0; day < 7; day++) {
        // ÌòÑÏû¨ ÎÇ†ÏßúÎ•º Í≥†Ï†ïÌïòÍ∏∞ ÏúÑÌï¥ ÏÉàÎ°úÏö¥ Date Í∞ùÏ≤¥ ÏÉùÏÑ±
        const cellDate = new Date(currentDay);
        const dateKey = cellDate.toISOString().split('T')[0];
        const dayData = calendarData[dateKey];
        const isCurrentMonth = cellDate.getMonth() === month;
        const isToday = cellDate.toDateString() === new Date().toDateString();
        const isSelected = cellDate.toDateString() === selectedDate.toDateString();

        weekDays.push(
          <div
            key={dateKey}
            className={`calendar-day ${isCurrentMonth ? 'current-month' : 'other-month'} ${
              isToday ? 'today' : ''
            } ${isSelected ? 'selected' : ''}`}
            onClick={() => setSelectedDate(new Date(cellDate))}
          >
            <div className="day-number">{cellDate.getDate()}</div>
            {isCurrentMonth && dayData && (
              <div className="day-indicators">
                {dayData.todos.length > 0 && (
                  <div className="indicator todo-indicator" title={`${dayData.todos.length}Í∞ú Ìï† Ïùº`}>
                    {dayData.todos.length}
                  </div>
                )}
                {dayData.completedTodos.length > 0 && (
                  <div className="indicator completed-indicator" title={`${dayData.completedTodos.length}Í∞ú ÏôÑÎ£å`}>
                    ‚úì
                  </div>
                )}
                {dayData.sleepData && (
                  <div className="indicator sleep-indicator" title="ÏàòÎ©¥ Í∏∞Î°ù">
                    üò¥
                  </div>
                )}
              </div>
            )}
          </div>
        );
        currentDay.setDate(currentDay.getDate() + 1);
      }
      days.push(
        <div key={week} className="calendar-week">
          {weekDays}
        </div>
      );
    }

    return days;
  };

  // ÏÑ†ÌÉùÎêú ÎÇ†ÏßúÏùò ÏÉÅÏÑ∏ Ï†ïÎ≥¥
  const selectedDateKey = selectedDate.toISOString().split('T')[0];
  const selectedDayData = calendarData[selectedDateKey];

  if (loading) {
    return (
      <div className="calendar-loading">
        <div className="loading-spinner"></div>
        <p>Ï∫òÎ¶∞ÎçîÎ•º Î∂àÎü¨Ïò§Îäî Ï§ë...</p>
      </div>
    );
  }

  return (
    <div className="calendar-container">
      <div className="calendar-header">
        <div className="calendar-navigation">
          <button onClick={() => navigateMonth('prev')} className="nav-button">
            <ChevronLeftIcon className="nav-icon" />
          </button>
          <h1 className="calendar-title">
            {currentDate.getFullYear()}ÎÖÑ {currentDate.getMonth() + 1}Ïõî
          </h1>
          <button onClick={() => navigateMonth('next')} className="nav-button">
            <ChevronRightIcon className="nav-icon" />
          </button>
        </div>
      </div>

      <div className="calendar-content">
        <div className="calendar-grid">
          <div className="calendar-weekdays">
            {['Ïùº', 'Ïõî', 'Ìôî', 'Ïàò', 'Î™©', 'Í∏à', 'ÌÜ†'].map(day => (
              <div key={day} className="weekday">{day}</div>
            ))}
          </div>
          <div className="calendar-days">
            {renderCalendar()}
          </div>
        </div>

        <div className="day-details">
          <h2 className="details-title">
            {selectedDate.toLocaleDateString('ko-KR', { 
              year: 'numeric', 
              month: 'long', 
              day: 'numeric',
              weekday: 'long'
            })}
          </h2>

          {selectedDayData ? (
            <div className="details-content">
              {/* Ìï† Ïùº */}
              {selectedDayData.todos.length > 0 && (
                <div className="detail-section">
                  <h3 className="section-title">
                    <CheckCircleIcon className="section-icon" />
                    Ìï† Ïùº ({selectedDayData.todos.length})
                  </h3>
                  <div className="item-list">
                    {selectedDayData.todos.map(todo => (
                      <div key={todo.id} className="detail-item">
                        <span className="item-text">{todo.text}</span>
                        <span className="item-meta">
                          {todo.dueDate !== 'infinity' && 
                            new Date(todo.dueDate as Date).toLocaleTimeString('ko-KR', { 
                              hour: '2-digit', 
                              minute: '2-digit' 
                            })
                          }
                        </span>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {/* ÏôÑÎ£åÌïú Ïùº */}
              {selectedDayData.completedTodos.length > 0 && (
                <div className="detail-section">
                  <h3 className="section-title">
                    <CheckCircleIcon className="section-icon completed" />
                    ÏôÑÎ£åÌïú Ïùº ({selectedDayData.completedTodos.length})
                  </h3>
                  <div className="item-list">
                    {selectedDayData.completedTodos.map(todo => (
                      <div key={todo.id} className="detail-item completed">
                        <span className="item-text">{todo.text}</span>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {/* ÏàòÎ©¥ Í∏∞Î°ù */}
              {selectedDayData.sleepData && (
                <div className="detail-section">
                  <h3 className="section-title">
                    <ClockIcon className="section-icon" />
                    ÏàòÎ©¥ Í∏∞Î°ù
                  </h3>
                  <div className="sleep-info">
                    <div className="sleep-time">
                      <span>Ï∑®Ïπ®: {selectedDayData.sleepData.sleepStart.toLocaleTimeString('ko-KR')}</span>
                      <span>Í∏∞ÏÉÅ: {selectedDayData.sleepData.sleepEnd.toLocaleTimeString('ko-KR')}</span>
                      <span>ÏàòÎ©¥ÏãúÍ∞Ñ: {Math.floor(selectedDayData.sleepData.duration / 60)}ÏãúÍ∞Ñ {selectedDayData.sleepData.duration % 60}Î∂Ñ</span>
                    </div>
                    {Object.keys(selectedDayData.sleepData.counters).length > 0 && (
                      <div className="counters-info">
                        <h4>ÌôúÎèô Í∏∞Î°ù</h4>
                        {Object.entries(selectedDayData.sleepData.counters).map(([key, value]) => (
                          <div key={key} className="counter-item">
                            <span>{key}: {value}Ìöå</span>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                </div>
              )}

              {/* Î©îÎ™® */}
              {selectedDayData.memos.length > 0 && (
                <div className="detail-section">
                  <h3 className="section-title">
                    <DocumentTextIcon className="section-icon" />
                    Î©îÎ™® ({selectedDayData.memos.length})
                  </h3>
                  <div className="item-list">
                    {selectedDayData.memos.map(memo => (
                      <div key={memo.id} className="detail-item memo">
                        <span className="item-text">{memo.text}</span>
                        {memo.content && (
                          <span className="item-meta">{memo.content}</span>
                        )}
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {!selectedDayData.todos.length && 
               !selectedDayData.completedTodos.length && 
               !selectedDayData.sleepData && 
               !selectedDayData.memos.length && (
                <div className="empty-day">
                  <p>Ïù¥ ÎÇ†ÏóêÎäî Í∏∞Î°ùÎêú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.</p>
                </div>
              )}
            </div>
          ) : (
            <div className="empty-day">
              <p>Ïù¥ ÎÇ†ÏóêÎäî Í∏∞Î°ùÎêú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.</p>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default CalendarPage; 